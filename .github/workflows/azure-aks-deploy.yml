name: Build and Deploy to Azure AKS with Security Scanning

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  IMAGE_NAME: javascript-app
  NAMESPACE: javascript-namespace

jobs:
  build:
    name: Build and Security Scan
    runs-on: ubuntu-latest
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate build ID
        id: build-id
        run: echo "BUILD_ID=$(date +%Y%m%d)-${GITHUB_SHA::8}" >> $GITHUB_OUTPUT

      - name: Log in to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.REGISTRY_LOGIN_SERVER }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.REGISTRY_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=raw,value=${{ steps.build-id.outputs.BUILD_ID }}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          load: true

      - name: Install Trivy manually
        run: |
          # Install Trivy binary manually
          sudo apt-get update
          sudo apt-get install wget apt-transport-https gnupg lsb-release -y
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install trivy -y
          trivy --version

      - name: Run Trivy vulnerability scanner (Table format)
        run: |
          trivy image \
            --severity CRITICAL,HIGH \
            --ignore-unfixed \
            --format table \
            ${{ secrets.REGISTRY_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ steps.build-id.outputs.BUILD_ID }}

      - name: Run Trivy vulnerability scanner (SARIF format)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ secrets.REGISTRY_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ steps.build-id.outputs.BUILD_ID }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          ignore-unfixed: true
          exit-code: '1'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Push Docker image to ACR
        if: github.event_name != 'pull_request'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Security scan summary
        run: |
          echo "üîç Security Scan Summary"
          echo "======================="
          echo "Image: ${{ secrets.REGISTRY_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ steps.build-id.outputs.BUILD_ID }}"
          echo "Trivy scan completed with severity: CRITICAL,HIGH"
          echo "Ignore unfixed: true"
          echo "Exit code on vulnerabilities: 1"

  deploy:
    name: Deploy to Azure AKS
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Azure CLI
        run: |
          # Install Azure CLI
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
          az version

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Azure Login
        run: |
          az login --service-principal \
            --username ${{ secrets.AZURE_CLIENT_ID }} \
            --password ${{ secrets.AZURE_CLIENT_SECRET }} \
            --tenant ${{ secrets.AZURE_TENANT_ID }}
          
          az account set --subscription ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          az account show

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ secrets.AKS_RESOURCE_GROUP }} \
            --name ${{ secrets.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Verify cluster connection
        run: |
          kubectl cluster-info
          kubectl get nodes
          kubectl get namespaces

      - name: Generate build ID
        id: build-id
        run: echo "BUILD_ID=$(date +%Y%m%d)-${GITHUB_SHA::8}" >> $GITHUB_OUTPUT

      - name: Create simple deployment manifests
        run: |
          # Create ConfigMap
          cat <<EOF > configmap.yaml
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: javascript-app-config
            namespace: ${{ env.NAMESPACE }}
            labels:
              app: javascript-app
          data:
            NODE_ENV: "production"
            PORT: "8080"
          EOF

          # Create Deployment
          cat <<EOF > deployment.yaml
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: javascript-app-deployment
            namespace: ${{ env.NAMESPACE }}
            labels:
              app: javascript-app
          spec:
            replicas: 3
            selector:
              matchLabels:
                app: javascript-app
            template:
              metadata:
                labels:
                  app: javascript-app
              spec:
                securityContext:
                  runAsNonRoot: true
                  runAsUser: 1001
                  runAsGroup: 1001
                  fsGroup: 1001
                containers:
                - name: javascript-app
                  image: ${{ secrets.REGISTRY_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ steps.build-id.outputs.BUILD_ID }}
                  imagePullPolicy: Always
                  ports:
                  - containerPort: 8080
                    name: http
                  env:
                  - name: NODE_ENV
                    valueFrom:
                      configMapKeyRef:
                        name: javascript-app-config
                        key: NODE_ENV
                  - name: PORT
                    valueFrom:
                      configMapKeyRef:
                        name: javascript-app-config
                        key: PORT
                  resources:
                    requests:
                      cpu: 250m
                      memory: 256Mi
                    limits:
                      cpu: 500m
                      memory: 512Mi
                  securityContext:
                    runAsNonRoot: true
                    runAsUser: 1001
                    runAsGroup: 1001
                    readOnlyRootFilesystem: true
                    allowPrivilegeEscalation: false
                    capabilities:
                      drop:
                      - ALL
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8080
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 8080
                    initialDelaySeconds: 5
                    periodSeconds: 5
                  volumeMounts:
                  - name: tmp-volume
                    mountPath: /tmp
                  - name: var-cache-volume
                    mountPath: /var/cache/nginx
                  - name: var-run-volume
                    mountPath: /var/run
                volumes:
                - name: tmp-volume
                  emptyDir: {}
                - name: var-cache-volume
                  emptyDir: {}
                - name: var-run-volume
                  emptyDir: {}
          EOF

          # Create Service
          cat <<EOF > service.yaml
          apiVersion: v1
          kind: Service
          metadata:
            name: javascript-app-service
            namespace: ${{ env.NAMESPACE }}
            labels:
              app: javascript-app
          spec:
            type: ClusterIP
            ports:
            - port: 80
              targetPort: 8080
              protocol: TCP
              name: http
            selector:
              app: javascript-app
          EOF

      - name: Deploy to AKS
        run: |
          echo "üöÄ Deploying to AKS cluster..."
          
          # Check if namespace exists, create if not
          if ! kubectl get namespace ${{ env.NAMESPACE }} &> /dev/null; then
            echo "Creating namespace ${{ env.NAMESPACE }}..."
            kubectl create namespace ${{ env.NAMESPACE }}
          fi
          
          # Apply manifests
          echo "Applying ConfigMap..."
          kubectl apply -f configmap.yaml
          
          echo "Applying Deployment..."
          kubectl apply -f deployment.yaml
          
          echo "Applying Service..."
          kubectl apply -f service.yaml
          
          # Wait for deployment to complete
          echo "Waiting for deployment to complete..."
          kubectl rollout status deployment/javascript-app-deployment -n ${{ env.NAMESPACE }} --timeout=300s

      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          
          # Check pods
          echo "Pods status:"
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=javascript-app
          
          # Check services
          echo "Services:"
          kubectl get svc -n ${{ env.NAMESPACE }} -l app=javascript-app
          
          # Check deployment
          echo "Deployment status:"
          kubectl get deployment -n ${{ env.NAMESPACE }} javascript-app-deployment
          
          # Wait for pods to be ready
          kubectl wait --for=condition=Ready pod -l app=javascript-app -n ${{ env.NAMESPACE }} --timeout=300s
          
          # Test health endpoint (port-forward method)
          echo "Testing application health..."
          kubectl port-forward -n ${{ env.NAMESPACE }} svc/javascript-app-service 8080:80 &
          PF_PID=$!
          sleep 10
          
          if curl -f http://localhost:8080/health; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ùå Health check failed"
            exit 1
          fi
          
          # Clean up port-forward
          kill $PF_PID 2>/dev/null || true

      - name: Deployment summary
        run: |
          echo "üéâ Deployment Summary"
          echo "===================="
          echo "‚úÖ Image: ${{ secrets.REGISTRY_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ steps.build-id.outputs.BUILD_ID }}"
          echo "‚úÖ Namespace: ${{ env.NAMESPACE }}"
          echo "‚úÖ Cluster: ${{ secrets.AKS_CLUSTER_NAME }}"
          echo "‚úÖ Resource Group: ${{ secrets.AKS_RESOURCE_GROUP }}"
          echo "‚úÖ Replicas: 3"
          echo "‚úÖ Environment: production"
          
          # Get external endpoint if available
          EXTERNAL_IP=$(kubectl get svc -n ${{ env.NAMESPACE }} javascript-app-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "ClusterIP")
          echo "‚úÖ Service Type: ClusterIP"
          echo "‚úÖ Internal Access: javascript-app-service.${{ env.NAMESPACE }}.svc.cluster.local"

      - name: Cleanup on failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed. Checking logs..."
          
          # Get pod logs
          kubectl logs -l app=javascript-app -n ${{ env.NAMESPACE }} --tail=100 || true
          
          # Describe pods
          kubectl describe pods -l app=javascript-app -n ${{ env.NAMESPACE }} || true
          
          # Get events
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -20 || true
          
          echo "üí° To troubleshoot:"
          echo "kubectl logs -l app=javascript-app -n ${{ env.NAMESPACE }}"
          echo "kubectl describe pods -l app=javascript-app -n ${{ env.NAMESPACE }}"
          echo "kubectl get events -n ${{ env.NAMESPACE }}"

      - name: Security validation
        run: |
          echo "üîí Post-deployment security validation..."
          
          # Check security context
          echo "Checking security context..."
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=javascript-app -o jsonpath='{.items[*].spec.securityContext}' | grep -q "runAsNonRoot" && echo "‚úÖ Running as non-root" || echo "‚ùå Running as root"
          
          # Check resource limits
          echo "Checking resource limits..."
          kubectl describe pods -n ${{ env.NAMESPACE }} -l app=javascript-app | grep -A 5 "Limits" | head -10
          
          # Check image
          echo "Deployed image:"
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=javascript-app -o jsonpath='{.items[*].spec.containers[*].image}'
          
          echo "üîí Security validation completed"
